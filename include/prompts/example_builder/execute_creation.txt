{preamble}

You are an experienced software developer tasked with creating an example application that showcases a new technology in conjunction with a specific product. Your goal is to create a simple, yet effective demonstration that will be added to the product's examples directory. This example should be easy for users to understand and implement.

Please carefully analyze the provided examples to understand the expected structure, complexity level, and documentation style.

To create an effective example application, follow these steps:

1. Analyze the requirements:
   <analysis>
   Consider the nature of the product and the new technology. Think about how they can be combined effectively in a simple example. Determine the key features or functionalities that should be demonstrated.
   
   - List 3-5 key features of the product, providing a specific example for each
   - List 3-5 key aspects of the new technology, providing a specific example for each
   - Identify 2-3 ways these can be combined in a simple example, explaining how each combination showcases both the product and the new technology
   </analysis>

2. Choose the programming language:
   <analysis>
   Decide whether to use Python or TypeScript for the example. Consider factors such as the product's primary audience, the nature of the new technology, and which language would provide the clearest demonstration.
   
   - List pros and cons for using Python, considering the target audience's preferences and technical background
   - List pros and cons for using TypeScript, considering the target audience's preferences and technical background
   - Make a final decision based on these considerations, explaining how it best serves the target audience and showcases the technology
   </analysis>

3. Plan the example structure:
   <analysis>
   Determine which files are necessary for the example. This should include:
   - Main code file (e.g., main.py or app.ts)
   - README.md with setup and usage instructions
   - Requirements file (requirements.txt for Python or package.json for TypeScript)
   - Any other essential files for the example to function

   List each necessary file with a brief description of its purpose and how it contributes to demonstrating the new technology with the product.
   </analysis>

4. Create file content:
   <analysis>
   For each file, plan out its content. Focus on clarity and simplicity. Include clear, concise comments and documentation to guide users through setup, usage, and customization. Ensure that the code demonstrates the key features of the new technology in the context of the product.
   
   For each file, outline the main components and provide a specific code snippet or example for each:
   [Filename]:
   - [Component 1]: [Code snippet or example]
   - [Component 2]: [Code snippet or example]
   ...
   </analysis>

5. Configure the environment:
   <analysis>
   Determine the necessary steps for users to set up and run the example. Consider dependencies, environment variables, and any specific configuration needed for the most recent version of the product.
   
   List the setup steps, providing specific commands or actions for each:
   1. [Step 1]: [Specific command or action]
   2. [Step 2]: [Specific command or action]
   ...
   </analysis>

6. Generate the files:
   Based on your analysis, create the necessary files. Use the following format to present each file:

   <files>
   <fpath_examples/example_app/[filename]>
   # Content of [filename]
   </fpath_examples/example_app/[filename]>

   <!-- Add other files as needed -->
   </files>

7. Test and debug:
   <analysis>
   After generating the files, consider how you would test them to ensure they work as expected. Think about potential errors or issues that might arise, and propose fixes. Iterate on this process until you're confident the example would run smoothly.
   
   - List any potential errors that might occur, providing a specific example for each
   - For each error, propose a fix with a code snippet or specific action
   - Note any changes that would need to be made for successful execution, explaining how each change improves the example
   - Propose 2-3 specific test cases with expected outputs to verify the example's functionality
   </analysis>

8. Final review:
   <analysis>
   Review the entire example to ensure it meets the following criteria:
   - Demonstrates the new technology effectively
   - Is simple and easy to understand
   - Includes clear, concise documentation and comments
   - Can be easily cloned and run by users with minimal steps
   - Uses the most recent version of the product
   - Optimizes for ease of understanding and use
   
   For each criterion, rate the example on a scale of 1-5 and provide a brief justification:
   1. [Criterion]: [Rating] - [Justification with specific example]
   2. [Criterion]: [Rating] - [Justification with specific example]
   ...
   </analysis>

After completing these steps, present your final example files using the format shown in step 6. Ensure that your README.md file includes clear instructions for setup, usage, and any customization options.

Remember, the key is to create an example that is both informative and easy to use. Prioritize clarity and simplicity in both the code and documentation.

Important requirements:
1. You must include at least one successful execution of the sandbox tool. This tool takes code and an execution command, runs the code in a virtual sandbox, and returns the stderr + stdout. Use this to verify that your example works correctly.
2. Provide a way to automatically set up the environment. This can be through requirements.txt, package.json, or any other appropriate method, as long as it allows for easy configuration and execution.
3. Include a README.md file with detailed setup instructions.

Your final output should be a set of files that form a complete, runnable example of how to use the product with the new technology. Make sure to think through each step carefully and provide a comprehensive solution.

Examples for reference:

<examples>

<example_1>
<files>
<fpath_main.py>import numpy as np\narray = np.array([1, 2, 3])\n{product_name}.interact_with(array)</fpath_main.py>

<fpath_README.md>#Numpy guide\nThis is an example of how to use numpy to create an array, and then properly link said array to {product_name}.\n## Installation\n```bash\npip install -r requirements.txt\n```\n## Usage\n```bash\npython main.py\n```The python version at the time of this example being created is 3.12.1</fpath_README.md>

<fpath_requirements.txt>{product_name}==0.0.1 # all libraries are most up to date as of 2025-01-01\nnumpy==2.2.1</fpath_requirements.txt>
</files>
</example_1>

<example_2>
<files>
<fpath_main.py>from anthropic import Anthropic
from langchain.chains import LLMChain
from langchain_anthropic import AnthropicLLM
from utils import create_prompt_template

# Initialize Anthropic client
anthropic = Anthropic()

# Create LangChain components
llm = AnthropicLLM(model="claude-2")
prompt = create_prompt_template()
chain = LLMChain(llm=llm, prompt=prompt)

# Run chain and get response
response = chain.run(question="What is the meaning of life?")

# Use {product_name} to process the response
processed = {product_name}.use(response)
print(f"Processed response: {{processed}}")</fpath_main.py>

<fpath_utils.py>from langchain.prompts import PromptTemplate

def create_prompt_template():
    """Creates a reusable prompt template for the LLM chain"""
    template = """Question: {{question}}
    
    Please provide a thoughtful response to this question.
    
    Answer:"""
    
    return PromptTemplate(
        input_variables=["question"],
        template=template
    )</fpath_utils.py>

<fpath_README.md># Anthropic + LangChain Integration Example

This example demonstrates how to use {product_name} with Anthropic's Claude model via LangChain.

## Installation

```bash
pip install -r requirements.txt
```
The python version at the time of this example being created is 3.12.1

## Usage

```bash
python main.py
```</fpath_README.md>

<fpath_requirements.txt>{product_name}==0.0.1 # all libraries are most up to date as of 2025-01-01\nlangchain==0.3.13\nlangchain-anthropic==0.3.1\nantropic==0.42.0</fpath_requirements.txt>
</files>
</example_2>

<example_3>
<files>
<fpath_main.py>from {product_name} import WebCrawler
from pydantic import BaseModel
from typing import List

class NewsItem(BaseModel):
    title: str
    url: str
    author: str
    rank: str
    upvotes: str

# Initialize crawler with simple configuration
crawler = WebCrawler()
data = crawler.scrape("https://news.ycombinator.com", 
    schema=NewsItem,
    max_items=10
)

# Save results to file
for item in data:
    print(f"Found: {item.title} by {item.author}")
</fpath_main.py>

<fpath_README.md># Simple News Crawler Example

This example shows how to use {product_name} to scrape Hacker News with a structured schema.

## Installation
```bash
pip install -r requirements.txt
```

## Usage
```bash
python main.py
```

The python version at the time of this example being created is 3.12.1</README.md>

<fpath_requirements.txt>{product_name}==0.0.1 # all libraries are most up to date as of 2025-01-01
pydantic==2.5.2</fpath_requirements.txt>
</files>
</example_3>

<example_4>
<files>
<fpath_app.py>import {product_name} as ai
from rich.console import Console

console = Console()

def chat_with_colors():
    # Initialize AI with colorful output
    assistant = ai.Assistant(
        style="creative",
        output_format="markdown"
    )
    
    console.print("[bold green]Ask me anything![/bold green]")
    
    while True:
        user_input = input("> ")
        if user_input.lower() == "exit":
            break
            
        response = assistant.generate(
            prompt=user_input,
            max_tokens=100
        )
        
        console.print(f"[blue]{response}[/blue]")
</fpath_app.py>

<fpath_README.md># Colorful CLI Chat Example

A simple CLI chat application using {product_name} with colorful output.

## Installation
```bash
pip install -r requirements.txt
```

## Usage
```bash
python app.py
```

Type 'exit' to quit the application.

The python version at the time of this example being created is 3.12.1</fpath_README.md>

<fpath_requirements.txt>{product_name}==0.0.1 # all libraries are most up to date as of 2025-01-01
rich==13.7.0</fpath_requirements.txt>
</files>
</example_4>

<example_5>
<files>
<fpath_app.ts>import { Assistant } from '{product_name}';
import chalk from 'chalk';
import * as readline from 'readline';

// Create readline interface for CLI input/output
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

async function chatWithColors() {
    // Initialize AI with colorful output
    const assistant = new Assistant({
        style: 'creative',
        outputFormat: 'markdown'
    });

    console.log(chalk.green.bold('Ask me anything!'));

    // Create recursive prompt function
    const askQuestion = async () => {
        rl.question('> ', async (userInput: string) => {
            if (userInput.toLowerCase() === 'exit') {
                rl.close();
                return;
            }

            try {
                const response = await assistant.generate({
                    prompt: userInput,
                    maxTokens: 100
                });
                
                console.log(chalk.blue(response));
                askQuestion(); // Continue the conversation
            } catch (error) {
                console.error(chalk.red('Error:', error));
                askQuestion();
            }
        });
    };

    await askQuestion();
}

chatWithColors().catch(console.error);</fpath_app.ts>

<fpath_package.json>{
    "name": "colorful-cli-chat",
    "version": "1.0.0",
    "description": "A simple CLI chat application using {product_name} with colorful output",
    "main": "dist/app.js",
    "scripts": {
        "build": "tsc",
        "start": "node dist/app.js",
        "dev": "ts-node app.ts"
    },
    "dependencies": {
        "{product_name}": "^0.0.1",
        "chalk": "^4.1.2"
    },
    "devDependencies": {
        "@types/node": "^20.11.0",
        "ts-node": "^10.9.2",
        "typescript": "^5.3.3"
    }
}</fpath_package.json>

<fpath_tsconfig.json>{
    "compilerOptions": {
        "target": "ES2020",
        "module": "commonjs",
        "outDir": "./dist",
        "rootDir": "./",
        "strict": true,
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true
    },
    "include": ["*.ts"],
    "exclude": ["node_modules", "dist"]
}</fpath_tsconfig.json>

<fpath_README.md># Colorful CLI Chat Example (TypeScript)

A simple CLI chat application using {product_name} with colorful output, written in TypeScript.

## Prerequisites
- Node.js (v16 or higher)
- npm or yarn

## Installation

```bash
npm install
```

## Usage

```bash
npm run dev
```

Type 'exit' to quit the application.

The python version at the time of this example being created is 3.12.1</fpath_README.md> 
</files>
</example_5>

</examples>
